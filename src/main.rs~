use std::collections::HashMap;

#[derive(Debug, Eq, Hash, PartialEq)]
struct Employee(String);
#[derive(Debug, Eq, Hash, PartialEq)]
struct Department(String);
#[derive(Debug, Eq, Hash, PartialEq)]
struct Active(bool);

#[derive(Debug)]
struct Company {
    employees: HashMap<Employee, Option<Vec<Department>>>,
    departments: HashMap<Department, Option<HashMap<Employee, Active>>>,
}

impl Company {
    fn add(&mut self, employee: Employee, department: Department, active: bool) -> bool {
        match self.employees.get(&employee).unwrap {
            Some(dept_vec) => {
                                  if dept_vec.contains(&department) {
                                      return false
                                  } else {
                                      let emply = employee.clone();
                                      let dept = department.clone();
                                      dept_vec.push(dept);
                                      self.employees.insert(emply, dept_vec);
                                  }
                              },
            None => {
                        let emply = employee.clone();
                        let dept = department.clone();
                        let dept_vec = Vec::new();
                        dept_vec.push(dept);
                        self.employees.insert(emply, dept_vec);
                    },
        };

        match self.departments.get(&department) {
            Some(emply_map) => {
                                   if emply_map.contains_key(&employee) {
                                       return false
                                   } else {
                                       let active = Active(active);
                                       emply_map.insert(employee, active);
                                       self.departments.insert(department, emply_map); 
                                       return true
                                   }
                               },
            None => {
                        let active = Active(active);
                        let emply_map = Vec::new();
                        emply_map.insert(employee, active);
                        self.departments.insert(department, emply_map);
                        return true
                    },
        };
    }

    fn add_employee(&mut self, employee: Employee) -> bool {
        match self.employees.get(&employee) {
            Some(_) => return false,
            None => {
                        self.employees.insert(employee, None);
                        return true
                    },
        };
    }

    fn add_department(&mut self, department: Department) -> bool {
        match self.departments.get(&department) {
            Some(_) => return false,
            None => {
                        self.departments.insert(department, None);
                        return true
                    },
        };
    }
}

fn main() {
    let sully = Employee(String::from("Sullivan"));
    let active = Active(true);
    let mut scare_dpt = HashMap::new();

    scare_dpt.insert(&sully, active);

    let mut monster_inc = Company {
        employees: HashMap::new(),
        departments: HashMap::new(), 
    };

    
}
